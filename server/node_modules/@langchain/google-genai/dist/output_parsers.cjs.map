{"version":3,"file":"output_parsers.cjs","names":["BaseLLMOutputParser","OutputParserException"],"sources":["../src/output_parsers.ts"],"sourcesContent":["import {\n  BaseLLMOutputParser,\n  OutputParserException,\n} from \"@langchain/core/output_parsers\";\nimport { ChatGeneration } from \"@langchain/core/outputs\";\nimport { ToolCall } from \"@langchain/core/messages/tool\";\nimport {\n  InteropZodType,\n  interopSafeParseAsync,\n} from \"@langchain/core/utils/types\";\nimport { JsonOutputKeyToolsParserParamsInterop } from \"@langchain/core/output_parsers/openai_tools\";\n\ninterface GoogleGenerativeAIToolsOutputParserParams<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any>,\n> extends JsonOutputKeyToolsParserParamsInterop<T> {}\n\nexport class GoogleGenerativeAIToolsOutputParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> extends BaseLLMOutputParser<T> {\n  static lc_name() {\n    return \"GoogleGenerativeAIToolsOutputParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"google_genai\", \"output_parsers\"];\n\n  returnId = false;\n\n  /** The type of tool calls to return. */\n  keyName: string;\n\n  /** Whether to return only the first tool call. */\n  returnSingle = false;\n\n  zodSchema?: InteropZodType<T>;\n\n  constructor(params: GoogleGenerativeAIToolsOutputParserParams<T>) {\n    super(params);\n    this.keyName = params.keyName;\n    this.returnSingle = params.returnSingle ?? this.returnSingle;\n    this.zodSchema = params.zodSchema;\n  }\n\n  protected async _validateResult(result: unknown): Promise<T> {\n    if (this.zodSchema === undefined) {\n      return result as T;\n    }\n    const zodParsedResult = await interopSafeParseAsync(this.zodSchema, result);\n    if (zodParsedResult.success) {\n      return zodParsedResult.data;\n    } else {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${JSON.stringify(\n          result,\n          null,\n          2\n        )}\". Error: ${JSON.stringify(zodParsedResult.error.issues)}`,\n        JSON.stringify(result, null, 2)\n      );\n    }\n  }\n\n  async parseResult(generations: ChatGeneration[]): Promise<T> {\n    const tools = generations.flatMap((generation) => {\n      const { message } = generation;\n      if (!(\"tool_calls\" in message) || !Array.isArray(message.tool_calls)) {\n        return [];\n      }\n      return message.tool_calls as ToolCall[];\n    });\n    if (tools[0] === undefined) {\n      throw new Error(\n        \"No parseable tool calls provided to GoogleGenerativeAIToolsOutputParser.\"\n      );\n    }\n    const [tool] = tools;\n    const validatedResult = await this._validateResult(tool.args);\n    return validatedResult;\n  }\n}\n"],"mappings":";;;;AAiBA,IAAa,sCAAb,cAGUA,mDAAuB;CAC/B,OAAO,UAAU;AACf,SAAO;;CAGT,eAAe;EAAC;EAAa;EAAgB;EAAiB;CAE9D,WAAW;;CAGX;;CAGA,eAAe;CAEf;CAEA,YAAY,QAAsD;AAChE,QAAM,OAAO;AACb,OAAK,UAAU,OAAO;AACtB,OAAK,eAAe,OAAO,gBAAgB,KAAK;AAChD,OAAK,YAAY,OAAO;;CAG1B,MAAgB,gBAAgB,QAA6B;AAC3D,MAAI,KAAK,cAAc,OACrB,QAAO;EAET,MAAM,kBAAkB,6DAA4B,KAAK,WAAW,OAAO;AAC3E,MAAI,gBAAgB,QAClB,QAAO,gBAAgB;MAEvB,OAAM,IAAIC,qDACR,2BAA2B,KAAK,UAC9B,QACA,MACA,EACD,CAAC,YAAY,KAAK,UAAU,gBAAgB,MAAM,OAAO,IAC1D,KAAK,UAAU,QAAQ,MAAM,EAAE,CAChC;;CAIL,MAAM,YAAY,aAA2C;EAC3D,MAAM,QAAQ,YAAY,SAAS,eAAe;GAChD,MAAM,EAAE,YAAY;AACpB,OAAI,EAAE,gBAAgB,YAAY,CAAC,MAAM,QAAQ,QAAQ,WAAW,CAClE,QAAO,EAAE;AAEX,UAAO,QAAQ;IACf;AACF,MAAI,MAAM,OAAO,OACf,OAAM,IAAI,MACR,2EACD;EAEH,MAAM,CAAC,QAAQ;AAEf,SADwB,MAAM,KAAK,gBAAgB,KAAK,KAAK"}