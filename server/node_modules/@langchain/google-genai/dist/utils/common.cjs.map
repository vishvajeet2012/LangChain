{"version":3,"file":"common.cjs","names":["ChatMessage","AIMessage","ChatGenerationChunk","AIMessageChunk","schemaToGenerativeAIParameters","jsonSchemaToGeminiParameters"],"sources":["../../src/utils/common.ts"],"sourcesContent":["import {\n  EnhancedGenerateContentResponse,\n  Content,\n  Part,\n  type FunctionDeclarationsTool as GoogleGenerativeAIFunctionDeclarationsTool,\n  type FunctionDeclaration as GenerativeAIFunctionDeclaration,\n  POSSIBLE_ROLES,\n  FunctionCallPart,\n  TextPart,\n  FileDataPart,\n  InlineDataPart,\n  type GenerateContentResponse,\n} from \"@google/generative-ai\";\nimport {\n  AIMessage,\n  AIMessageChunk,\n  BaseMessage,\n  ChatMessage,\n  ToolMessage,\n  ToolMessageChunk,\n  MessageContent,\n  MessageContentComplex,\n  UsageMetadata,\n  isAIMessage,\n  isBaseMessage,\n  isToolMessage,\n  StandardContentBlockConverter,\n  parseBase64DataUrl,\n  convertToProviderContentBlock,\n  isDataContentBlock,\n  InputTokenDetails,\n} from \"@langchain/core/messages\";\nimport {\n  ChatGeneration,\n  ChatGenerationChunk,\n  ChatResult,\n} from \"@langchain/core/outputs\";\nimport { isLangChainTool } from \"@langchain/core/utils/function_calling\";\nimport { isOpenAITool } from \"@langchain/core/language_models/base\";\nimport { ToolCallChunk } from \"@langchain/core/messages/tool\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport {\n  jsonSchemaToGeminiParameters,\n  schemaToGenerativeAIParameters,\n} from \"./zod_to_genai_parameters.js\";\nimport {\n  GoogleGenerativeAIPart,\n  GoogleGenerativeAIToolType,\n} from \"../types.js\";\nimport { assertNoEmptyStringEnums } from \"./validate_schema.js\";\n\nexport const _FUNCTION_CALL_THOUGHT_SIGNATURES_MAP_KEY =\n  \"__gemini_function_call_thought_signatures__\";\nconst DUMMY_SIGNATURE =\n  \"ErYCCrMCAdHtim9kOoOkrPiCNVsmlpMIKd7ZMxgiFbVQOkgp7nlLcDMzVsZwIzvuT7nQROivoXA72ccC2lSDvR0Gh7dkWaGuj7ctv6t7ZceHnecx0QYa+ix8tYpRfjhyWozQ49lWiws6+YGjCt10KRTyWsZ2h6O7iHTYJwKIRwGUHRKy/qK/6kFxJm5ML00gLq4D8s5Z6DBpp2ZlR+uF4G8jJgeWQgyHWVdx2wGYElaceVAc66tZdPQRdOHpWtgYSI1YdaXgVI8KHY3/EfNc2YqqMIulvkDBAnuMhkAjV9xmBa54Tq+ih3Im4+r3DzqhGqYdsSkhS0kZMwte4Hjs65dZzCw9lANxIqYi1DJ639WNPYihp/DCJCos7o+/EeSPJaio5sgWDyUnMGkY1atsJZ+m7pj7DD5tvQ==\";\n\nconst iife = (fn: () => string) => fn();\n\nexport function getMessageAuthor(message: BaseMessage) {\n  if (ChatMessage.isInstance(message)) {\n    return message.role;\n  }\n  return message.type;\n}\n\n/**\n * Maps a message type to a Google Generative AI chat author.\n * @param message The message to map.\n * @param model The model to use for mapping.\n * @returns The message type mapped to a Google Generative AI chat author.\n */\nexport function convertAuthorToRole(\n  author: string\n): (typeof POSSIBLE_ROLES)[number] {\n  switch (author) {\n    /**\n     *  Note: Gemini currently is not supporting system messages\n     *  we will convert them to human messages and merge with following\n     * */\n    case \"supervisor\":\n    case \"ai\":\n    case \"model\":\n      return \"model\";\n    case \"system\":\n      return \"system\";\n    case \"human\":\n      return \"user\";\n    case \"tool\":\n    case \"function\":\n      return \"function\";\n    default:\n      throw new Error(`Unknown / unsupported author: ${author}`);\n  }\n}\n\nfunction messageContentMedia(content: MessageContentComplex): Part {\n  if (\"mimeType\" in content && \"data\" in content) {\n    return {\n      inlineData: {\n        mimeType: content.mimeType,\n        data: content.data,\n      },\n    };\n  }\n  if (\"mimeType\" in content && \"fileUri\" in content) {\n    return {\n      fileData: {\n        mimeType: content.mimeType,\n        fileUri: content.fileUri,\n      },\n    };\n  }\n\n  throw new Error(\"Invalid media content\");\n}\n\nfunction inferToolNameFromPreviousMessages(\n  message: ToolMessage | ToolMessageChunk,\n  previousMessages: BaseMessage[]\n): string | undefined {\n  return previousMessages\n    .map((msg) => {\n      if (isAIMessage(msg)) {\n        return msg.tool_calls ?? [];\n      }\n      return [];\n    })\n    .flat()\n    .find((toolCall) => {\n      return toolCall.id === message.tool_call_id;\n    })?.name;\n}\n\nfunction _getStandardContentBlockConverter(isMultimodalModel: boolean) {\n  const standardContentBlockConverter: StandardContentBlockConverter<{\n    text: TextPart;\n    image: FileDataPart | InlineDataPart;\n    audio: FileDataPart | InlineDataPart;\n    file: FileDataPart | InlineDataPart | TextPart;\n  }> = {\n    providerName: \"Google Gemini\",\n\n    fromStandardTextBlock(block) {\n      return {\n        text: block.text,\n      };\n    },\n\n    fromStandardImageBlock(block): FileDataPart | InlineDataPart {\n      if (!isMultimodalModel) {\n        throw new Error(\"This model does not support images\");\n      }\n      if (block.source_type === \"url\") {\n        const data = parseBase64DataUrl({ dataUrl: block.url });\n        if (data) {\n          return {\n            inlineData: {\n              mimeType: data.mime_type,\n              data: data.data,\n            },\n          };\n        } else {\n          return {\n            fileData: {\n              mimeType: block.mime_type ?? \"\",\n              fileUri: block.url,\n            },\n          };\n        }\n      }\n\n      if (block.source_type === \"base64\") {\n        return {\n          inlineData: {\n            mimeType: block.mime_type ?? \"\",\n            data: block.data,\n          },\n        };\n      }\n\n      throw new Error(`Unsupported source type: ${block.source_type}`);\n    },\n\n    fromStandardAudioBlock(block): FileDataPart | InlineDataPart {\n      if (!isMultimodalModel) {\n        throw new Error(\"This model does not support audio\");\n      }\n      if (block.source_type === \"url\") {\n        const data = parseBase64DataUrl({ dataUrl: block.url });\n        if (data) {\n          return {\n            inlineData: {\n              mimeType: data.mime_type,\n              data: data.data,\n            },\n          };\n        } else {\n          return {\n            fileData: {\n              mimeType: block.mime_type ?? \"\",\n              fileUri: block.url,\n            },\n          };\n        }\n      }\n\n      if (block.source_type === \"base64\") {\n        return {\n          inlineData: {\n            mimeType: block.mime_type ?? \"\",\n            data: block.data,\n          },\n        };\n      }\n\n      throw new Error(`Unsupported source type: ${block.source_type}`);\n    },\n\n    fromStandardFileBlock(block): FileDataPart | InlineDataPart | TextPart {\n      if (!isMultimodalModel) {\n        throw new Error(\"This model does not support files\");\n      }\n      if (block.source_type === \"text\") {\n        return {\n          text: block.text,\n        };\n      }\n      if (block.source_type === \"url\") {\n        const data = parseBase64DataUrl({ dataUrl: block.url });\n        if (data) {\n          return {\n            inlineData: {\n              mimeType: data.mime_type,\n              data: data.data,\n            },\n          };\n        } else {\n          return {\n            fileData: {\n              mimeType: block.mime_type ?? \"\",\n              fileUri: block.url,\n            },\n          };\n        }\n      }\n\n      if (block.source_type === \"base64\") {\n        return {\n          inlineData: {\n            mimeType: block.mime_type ?? \"\",\n            data: block.data,\n          },\n        };\n      }\n      throw new Error(`Unsupported source type: ${block.source_type}`);\n    },\n  };\n  return standardContentBlockConverter;\n}\n\nfunction _convertLangChainContentToPart(\n  content: MessageContentComplex,\n  isMultimodalModel: boolean\n): Part | undefined {\n  if (isDataContentBlock(content)) {\n    return convertToProviderContentBlock(\n      content,\n      _getStandardContentBlockConverter(isMultimodalModel)\n    );\n  }\n\n  if (content.type === \"text\") {\n    return { text: content.text };\n  } else if (content.type === \"executableCode\") {\n    return { executableCode: content.executableCode };\n  } else if (content.type === \"codeExecutionResult\") {\n    return { codeExecutionResult: content.codeExecutionResult };\n  } else if (content.type === \"image_url\") {\n    if (!isMultimodalModel) {\n      throw new Error(`This model does not support images`);\n    }\n    let source;\n    if (typeof content.image_url === \"string\") {\n      source = content.image_url;\n    } else if (\n      typeof content.image_url === \"object\" &&\n      \"url\" in content.image_url\n    ) {\n      source = content.image_url.url;\n    } else {\n      throw new Error(\"Please provide image as base64 encoded data URL\");\n    }\n    const [dm, data] = source.split(\",\");\n    if (!dm.startsWith(\"data:\")) {\n      throw new Error(\"Please provide image as base64 encoded data URL\");\n    }\n\n    const [mimeType, encoding] = dm.replace(/^data:/, \"\").split(\";\");\n    if (encoding !== \"base64\") {\n      throw new Error(\"Please provide image as base64 encoded data URL\");\n    }\n\n    return {\n      inlineData: {\n        data,\n        mimeType,\n      },\n    };\n  } else if (content.type === \"media\") {\n    return messageContentMedia(content);\n  } else if (content.type === \"tool_use\") {\n    return {\n      functionCall: {\n        name: content.name,\n        args: content.input,\n      },\n    };\n  } else if (content.type === \"tool_call\") {\n    return {\n      functionCall: {\n        name: content.name,\n        args: content.args,\n      },\n    };\n  } else if (\n    content.type?.includes(\"/\") &&\n    // Ensure it's a single slash.\n    content.type.split(\"/\").length === 2 &&\n    \"data\" in content &&\n    typeof content.data === \"string\"\n  ) {\n    return {\n      inlineData: {\n        mimeType: content.type,\n        data: content.data,\n      },\n    };\n  } else if (\"functionCall\" in content) {\n    // No action needed here â€” function calls will be added later from message.tool_calls\n    return undefined;\n  } else {\n    if (\"type\" in content) {\n      throw new Error(`Unknown content type ${content.type}`);\n    } else {\n      throw new Error(`Unknown content ${JSON.stringify(content)}`);\n    }\n  }\n}\n\nexport function convertMessageContentToParts(\n  message: BaseMessage,\n  isMultimodalModel: boolean,\n  previousMessages: BaseMessage[],\n  model?: string\n): Part[] {\n  if (isToolMessage(message)) {\n    const messageName =\n      message.name ??\n      inferToolNameFromPreviousMessages(message, previousMessages);\n    if (messageName === undefined) {\n      throw new Error(\n        `Google requires a tool name for each tool call response, and we could not infer a called tool name for ToolMessage \"${message.id}\" from your passed messages. Please populate a \"name\" field on that ToolMessage explicitly.`\n      );\n    }\n\n    const result = Array.isArray(message.content)\n      ? (message.content\n          .map((c) => _convertLangChainContentToPart(c, isMultimodalModel))\n          .filter((p) => p !== undefined) as Part[])\n      : message.content;\n\n    if (message.status === \"error\") {\n      return [\n        {\n          functionResponse: {\n            name: messageName,\n            // The API expects an object with an `error` field if the function call fails.\n            // `error` must be a valid object (not a string or array), so we wrap `message.content` here\n            response: { error: { details: result } },\n          },\n        },\n      ];\n    }\n\n    return [\n      {\n        functionResponse: {\n          name: messageName,\n          // again, can't have a string or array value for `response`, so we wrap it as an object here\n          response: { result },\n        },\n      },\n    ];\n  }\n\n  let functionCalls: FunctionCallPart[] = [];\n  const messageParts: Part[] = [];\n\n  if (typeof message.content === \"string\" && message.content) {\n    messageParts.push({ text: message.content });\n  }\n\n  if (Array.isArray(message.content)) {\n    messageParts.push(\n      ...(message.content\n        .map((c) => _convertLangChainContentToPart(c, isMultimodalModel))\n        .filter((p) => p !== undefined) as Part[])\n    );\n  }\n\n  const functionThoughtSignatures = message.additional_kwargs?.[\n    _FUNCTION_CALL_THOUGHT_SIGNATURES_MAP_KEY\n  ] as Record<string, string>;\n\n  if (isAIMessage(message) && message.tool_calls?.length) {\n    functionCalls = message.tool_calls.map((tc) => {\n      const thoughtSignature = iife(() => {\n        if (tc.id) {\n          const signature = functionThoughtSignatures?.[tc.id];\n          if (signature) {\n            return signature;\n          }\n        }\n        if (model?.includes(\"gemini-3\")) {\n          return DUMMY_SIGNATURE;\n        }\n        return \"\";\n      });\n      return {\n        functionCall: {\n          name: tc.name,\n          args: tc.args,\n        },\n        ...(thoughtSignature ? { thoughtSignature } : {}),\n      };\n    });\n  }\n\n  return [...messageParts, ...functionCalls];\n}\n\nexport function convertBaseMessagesToContent(\n  messages: BaseMessage[],\n  isMultimodalModel: boolean,\n  convertSystemMessageToHumanContent: boolean = false,\n  model: string\n) {\n  return messages.reduce<{\n    content: Content[];\n    mergeWithPreviousContent: boolean;\n  }>(\n    (acc, message, index) => {\n      if (!isBaseMessage(message)) {\n        throw new Error(\"Unsupported message input\");\n      }\n      const author = getMessageAuthor(message);\n      if (author === \"system\" && index !== 0) {\n        throw new Error(\"System message should be the first one\");\n      }\n      const role = convertAuthorToRole(author);\n\n      const prevContent = acc.content[acc.content.length];\n      if (\n        !acc.mergeWithPreviousContent &&\n        prevContent &&\n        prevContent.role === role\n      ) {\n        throw new Error(\n          \"Google Generative AI requires alternate messages between authors\"\n        );\n      }\n\n      const parts = convertMessageContentToParts(\n        message,\n        isMultimodalModel,\n        messages.slice(0, index),\n        model\n      );\n\n      if (acc.mergeWithPreviousContent) {\n        const prevContent = acc.content[acc.content.length - 1];\n        if (!prevContent) {\n          throw new Error(\n            \"There was a problem parsing your system message. Please try a prompt without one.\"\n          );\n        }\n        prevContent.parts.push(...parts);\n\n        return {\n          mergeWithPreviousContent: false,\n          content: acc.content,\n        };\n      }\n      let actualRole = role;\n      if (\n        actualRole === \"function\" ||\n        (actualRole === \"system\" && !convertSystemMessageToHumanContent)\n      ) {\n        // GenerativeAI API will throw an error if the role is not \"user\" or \"model.\"\n        actualRole = \"user\";\n      }\n      const content: Content = {\n        role: actualRole,\n        parts,\n      };\n      return {\n        mergeWithPreviousContent:\n          author === \"system\" && !convertSystemMessageToHumanContent,\n        content: [...acc.content, content],\n      };\n    },\n    { content: [], mergeWithPreviousContent: false }\n  ).content;\n}\n\nexport function mapGenerateContentResultToChatResult(\n  response: EnhancedGenerateContentResponse,\n  extra?: {\n    usageMetadata: UsageMetadata | undefined;\n  }\n): ChatResult {\n  // if rejected or error, return empty generations with reason in filters\n  if (\n    !response.candidates ||\n    response.candidates.length === 0 ||\n    !response.candidates[0]\n  ) {\n    return {\n      generations: [],\n      llmOutput: {\n        filters: response.promptFeedback,\n      },\n    };\n  }\n  const [candidate] = response.candidates;\n  const { content: candidateContent, ...generationInfo } = candidate;\n  const functionCalls = candidateContent.parts?.reduce(\n    (acc, p) => {\n      if (\"functionCall\" in p && p.functionCall) {\n        acc.push({\n          ...p,\n          id:\n            \"id\" in p.functionCall && typeof p.functionCall.id === \"string\"\n              ? p.functionCall.id\n              : uuidv4(),\n        });\n      }\n      return acc;\n    },\n    [] as (FunctionCallPart & { id: string })[]\n  );\n  let content: MessageContent | undefined;\n\n  const parts = candidateContent?.parts as GoogleGenerativeAIPart[] | undefined;\n\n  if (\n    Array.isArray(parts) &&\n    parts.length === 1 &&\n    \"text\" in parts[0] &&\n    parts[0].text &&\n    !parts[0].thought\n  ) {\n    content = parts[0].text;\n  } else if (Array.isArray(parts) && parts.length > 0) {\n    content = parts.map((p) => {\n      if (p.thought && \"text\" in p && p.text) {\n        return {\n          type: \"thinking\",\n          thinking: p.text,\n          ...(p.thoughtSignature ? { signature: p.thoughtSignature } : {}),\n        };\n      } else if (\"text\" in p) {\n        return {\n          type: \"text\",\n          text: p.text,\n        };\n      } else if (\"inlineData\" in p) {\n        return {\n          type: \"inlineData\",\n          inlineData: p.inlineData,\n        };\n      } else if (\"functionCall\" in p) {\n        return {\n          type: \"functionCall\",\n          functionCall: p.functionCall,\n        };\n      } else if (\"functionResponse\" in p) {\n        return {\n          type: \"functionResponse\",\n          functionResponse: p.functionResponse,\n        };\n      } else if (\"fileData\" in p) {\n        return {\n          type: \"fileData\",\n          fileData: p.fileData,\n        };\n      } else if (\"executableCode\" in p) {\n        return {\n          type: \"executableCode\",\n          executableCode: p.executableCode,\n        };\n      } else if (\"codeExecutionResult\" in p) {\n        return {\n          type: \"codeExecutionResult\",\n          codeExecutionResult: p.codeExecutionResult,\n        };\n      }\n      return p;\n    });\n  } else {\n    // no content returned - likely due to abnormal stop reason, e.g. malformed function call\n    content = [];\n  }\n\n  const functionThoughtSignatures = functionCalls?.reduce(\n    (acc, fc) => {\n      if (\"thoughtSignature\" in fc && typeof fc.thoughtSignature === \"string\") {\n        acc[fc.id] = fc.thoughtSignature;\n      }\n      return acc;\n    },\n    {} as Record<string, string>\n  );\n\n  let text = \"\";\n  if (typeof content === \"string\") {\n    text = content;\n  } else if (Array.isArray(content) && content.length > 0) {\n    const block = content.find((b) => \"text\" in b) as\n      | { text: string }\n      | undefined;\n    text = block?.text ?? text;\n  }\n\n  const generation: ChatGeneration = {\n    text,\n    message: new AIMessage({\n      content: content ?? \"\",\n      tool_calls: functionCalls?.map((fc) => ({\n        type: \"tool_call\",\n        id: fc.id,\n        name: fc.functionCall.name,\n        args: fc.functionCall.args,\n      })),\n      additional_kwargs: {\n        ...generationInfo,\n        [_FUNCTION_CALL_THOUGHT_SIGNATURES_MAP_KEY]: functionThoughtSignatures,\n      },\n      usage_metadata: extra?.usageMetadata,\n    }),\n    generationInfo,\n  };\n\n  return {\n    generations: [generation],\n    llmOutput: {\n      tokenUsage: {\n        promptTokens: extra?.usageMetadata?.input_tokens,\n        completionTokens: extra?.usageMetadata?.output_tokens,\n        totalTokens: extra?.usageMetadata?.total_tokens,\n      },\n    },\n  };\n}\n\nexport function convertResponseContentToChatGenerationChunk(\n  response: EnhancedGenerateContentResponse,\n  extra: {\n    usageMetadata?: UsageMetadata | undefined;\n    index: number;\n  }\n): ChatGenerationChunk | null {\n  if (!response.candidates || response.candidates.length === 0) {\n    return null;\n  }\n  const [candidate] = response.candidates;\n  const { content: candidateContent, ...generationInfo } = candidate;\n  const functionCalls = candidateContent.parts?.reduce(\n    (acc, p) => {\n      if (\"functionCall\" in p && p.functionCall) {\n        acc.push({\n          ...p,\n          id:\n            \"id\" in p.functionCall && typeof p.functionCall.id === \"string\"\n              ? p.functionCall.id\n              : uuidv4(),\n        });\n      }\n      return acc;\n    },\n    [] as (FunctionCallPart & { id: string })[]\n  );\n  let content: MessageContent | undefined;\n  const streamParts = candidateContent?.parts as\n    | GoogleGenerativeAIPart[]\n    | undefined;\n\n  // Checks if all parts are plain text (no thought flags). If so, join as string.\n  if (\n    Array.isArray(streamParts) &&\n    streamParts.every((p) => \"text\" in p && !p.thought)\n  ) {\n    content = streamParts.map((p) => p.text).join(\"\");\n  } else if (Array.isArray(streamParts)) {\n    content = streamParts.map((p) => {\n      if (p.thought && \"text\" in p && p.text) {\n        return {\n          type: \"thinking\",\n          thinking: p.text,\n          ...(p.thoughtSignature ? { signature: p.thoughtSignature } : {}),\n        };\n      } else if (\"text\" in p) {\n        return {\n          type: \"text\",\n          text: p.text,\n        };\n      } else if (\"inlineData\" in p) {\n        return {\n          type: \"inlineData\",\n          inlineData: p.inlineData,\n        };\n      } else if (\"functionCall\" in p) {\n        return {\n          type: \"functionCall\",\n          functionCall: p.functionCall,\n        };\n      } else if (\"functionResponse\" in p) {\n        return {\n          type: \"functionResponse\",\n          functionResponse: p.functionResponse,\n        };\n      } else if (\"fileData\" in p) {\n        return {\n          type: \"fileData\",\n          fileData: p.fileData,\n        };\n      } else if (\"executableCode\" in p) {\n        return {\n          type: \"executableCode\",\n          executableCode: p.executableCode,\n        };\n      } else if (\"codeExecutionResult\" in p) {\n        return {\n          type: \"codeExecutionResult\",\n          codeExecutionResult: p.codeExecutionResult,\n        };\n      }\n      return p;\n    });\n  } else {\n    // no content returned - likely due to abnormal stop reason, e.g. malformed function call\n    content = [];\n  }\n\n  let text = \"\";\n  if (content && typeof content === \"string\") {\n    text = content;\n  } else if (Array.isArray(content)) {\n    const block = content.find((b) => \"text\" in b) as\n      | { text: string }\n      | undefined;\n    text = block?.text ?? \"\";\n  }\n\n  const toolCallChunks: ToolCallChunk[] = [];\n  if (functionCalls) {\n    toolCallChunks.push(\n      ...functionCalls.map((fc) => ({\n        type: \"tool_call_chunk\" as const,\n        id: fc.id,\n        name: fc.functionCall.name,\n        args: JSON.stringify(fc.functionCall.args),\n      }))\n    );\n  }\n\n  const functionThoughtSignatures = functionCalls?.reduce(\n    (acc, fc) => {\n      if (\"thoughtSignature\" in fc && typeof fc.thoughtSignature === \"string\") {\n        acc[fc.id] = fc.thoughtSignature;\n      }\n      return acc;\n    },\n    {} as Record<string, string>\n  );\n\n  return new ChatGenerationChunk({\n    text,\n    message: new AIMessageChunk({\n      content: content || \"\",\n      name: !candidateContent ? undefined : candidateContent.role,\n      tool_call_chunks: toolCallChunks,\n      // Each chunk can have unique \"generationInfo\", and merging strategy is unclear,\n      // so leave blank for now.\n      additional_kwargs: {\n        [_FUNCTION_CALL_THOUGHT_SIGNATURES_MAP_KEY]: functionThoughtSignatures,\n      },\n      response_metadata: {\n        model_provider: \"google-genai\",\n      },\n      usage_metadata: extra.usageMetadata,\n    }),\n    generationInfo,\n  });\n}\n\nexport function convertToGenerativeAITools(\n  tools: GoogleGenerativeAIToolType[]\n): GoogleGenerativeAIFunctionDeclarationsTool[] {\n  if (\n    tools.every(\n      (tool) =>\n        \"functionDeclarations\" in tool &&\n        Array.isArray(tool.functionDeclarations)\n    )\n  ) {\n    return tools as GoogleGenerativeAIFunctionDeclarationsTool[];\n  }\n  return [\n    {\n      functionDeclarations: tools.map(\n        (tool): GenerativeAIFunctionDeclaration => {\n          if (isLangChainTool(tool)) {\n            const jsonSchema = schemaToGenerativeAIParameters(tool.schema);\n            if (\n              jsonSchema.type === \"object\" &&\n              \"properties\" in jsonSchema &&\n              Object.keys(jsonSchema.properties).length === 0\n            ) {\n              return {\n                name: tool.name,\n                description: tool.description,\n              };\n            }\n            assertNoEmptyStringEnums(jsonSchema, tool.name);\n            return {\n              name: tool.name,\n              description: tool.description,\n              parameters: jsonSchema,\n            };\n          }\n          if (isOpenAITool(tool)) {\n            const params = jsonSchemaToGeminiParameters(\n              tool.function.parameters\n            );\n            assertNoEmptyStringEnums(params, tool.function.name);\n            return {\n              name: tool.function.name,\n              description:\n                tool.function.description ?? `A function available to call.`,\n              parameters: params,\n            };\n          }\n          return tool as unknown as GenerativeAIFunctionDeclaration;\n        }\n      ),\n    },\n  ];\n}\n\nexport function convertUsageMetadata(\n  usageMetadata: GenerateContentResponse[\"usageMetadata\"],\n  model: string\n): UsageMetadata {\n  const output: UsageMetadata = {\n    input_tokens: usageMetadata?.promptTokenCount ?? 0,\n    output_tokens: usageMetadata?.candidatesTokenCount ?? 0,\n    total_tokens: usageMetadata?.totalTokenCount ?? 0,\n  };\n  if (usageMetadata?.cachedContentTokenCount) {\n    output.input_token_details ??= {};\n    output.input_token_details.cache_read =\n      usageMetadata.cachedContentTokenCount;\n  }\n  // gemini-3-pro-preview has bracket based tracking of tokens per request\n  // FIXME(hntrl): move this usageMetadata calculation elsewhere\n  if (model === \"gemini-3-pro-preview\") {\n    const over200k = Math.max(0, usageMetadata?.promptTokenCount ?? 0 - 200000);\n    const cachedOver200k = Math.max(\n      0,\n      usageMetadata?.cachedContentTokenCount ?? 0 - 200000\n    );\n    if (over200k) {\n      output.input_token_details = {\n        ...output.input_token_details,\n        over_200k: over200k,\n      } as InputTokenDetails;\n    }\n    if (cachedOver200k) {\n      output.input_token_details = {\n        ...output.input_token_details,\n        cache_read_over_200k: cachedOver200k,\n      } as InputTokenDetails;\n    }\n  }\n  return output;\n}\n"],"mappings":"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"}