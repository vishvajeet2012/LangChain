{"version":3,"file":"tools.js","names":[],"sources":["../../src/utils/tools.ts"],"sourcesContent":["import {\n  Tool as GenerativeAITool,\n  ToolConfig,\n  FunctionCallingMode,\n  FunctionDeclaration,\n  FunctionDeclarationsTool,\n  FunctionDeclarationSchema,\n} from \"@google/generative-ai\";\nimport { ToolChoice } from \"@langchain/core/language_models/chat_models\";\nimport { StructuredToolInterface } from \"@langchain/core/tools\";\nimport { isLangChainTool } from \"@langchain/core/utils/function_calling\";\nimport {\n  isOpenAITool,\n  ToolDefinition,\n} from \"@langchain/core/language_models/base\";\nimport { convertToGenerativeAITools } from \"./common.js\";\nimport { GoogleGenerativeAIToolType } from \"../types.js\";\nimport { removeAdditionalProperties } from \"./zod_to_genai_parameters.js\";\n\nexport function convertToolsToGenAI(\n  tools: GoogleGenerativeAIToolType[],\n  extra?: {\n    toolChoice?: ToolChoice;\n    allowedFunctionNames?: string[];\n  }\n): {\n  tools: GenerativeAITool[];\n  toolConfig?: ToolConfig;\n} {\n  // Extract function declaration processing to a separate function\n  const genAITools = processTools(tools);\n\n  // Simplify tool config creation\n  const toolConfig = createToolConfig(genAITools, extra);\n\n  return { tools: genAITools, toolConfig };\n}\n\nfunction processTools(tools: GoogleGenerativeAIToolType[]): GenerativeAITool[] {\n  let functionDeclarationTools: FunctionDeclaration[] = [];\n  const genAITools: GenerativeAITool[] = [];\n\n  tools.forEach((tool) => {\n    if (isLangChainTool(tool)) {\n      const [convertedTool] = convertToGenerativeAITools([\n        tool as StructuredToolInterface,\n      ]);\n      if (convertedTool.functionDeclarations) {\n        functionDeclarationTools.push(...convertedTool.functionDeclarations);\n      }\n    } else if (isOpenAITool(tool)) {\n      const { functionDeclarations } = convertOpenAIToolToGenAI(tool);\n      if (functionDeclarations) {\n        functionDeclarationTools.push(...functionDeclarations);\n      } else {\n        throw new Error(\n          \"Failed to convert OpenAI structured tool to GenerativeAI tool\"\n        );\n      }\n    } else {\n      genAITools.push(tool as GenerativeAITool);\n    }\n  });\n\n  const genAIFunctionDeclaration = genAITools.find(\n    (t) => \"functionDeclarations\" in t\n  );\n  if (genAIFunctionDeclaration) {\n    return genAITools.map((tool) => {\n      if (\n        functionDeclarationTools?.length > 0 &&\n        \"functionDeclarations\" in tool\n      ) {\n        const newTool = {\n          functionDeclarations: [\n            ...(tool.functionDeclarations || []),\n            ...functionDeclarationTools,\n          ],\n        };\n        // Clear the functionDeclarationTools array so it is not passed again\n        functionDeclarationTools = [];\n        return newTool;\n      }\n      return tool;\n    });\n  }\n\n  return [\n    ...genAITools,\n    ...(functionDeclarationTools.length > 0\n      ? [\n          {\n            functionDeclarations: functionDeclarationTools,\n          },\n        ]\n      : []),\n  ];\n}\n\nfunction convertOpenAIToolToGenAI(\n  tool: ToolDefinition\n): FunctionDeclarationsTool {\n  return {\n    functionDeclarations: [\n      {\n        name: tool.function.name,\n        description: tool.function.description,\n        parameters: removeAdditionalProperties(\n          tool.function.parameters\n        ) as FunctionDeclarationSchema,\n      },\n    ],\n  };\n}\n\nfunction createToolConfig(\n  genAITools: GenerativeAITool[],\n  extra?: {\n    toolChoice?: ToolChoice;\n    allowedFunctionNames?: string[];\n  }\n): ToolConfig | undefined {\n  if (!genAITools.length || !extra) return undefined;\n\n  const { toolChoice, allowedFunctionNames } = extra;\n\n  const modeMap: Record<string, FunctionCallingMode> = {\n    any: FunctionCallingMode.ANY,\n    auto: FunctionCallingMode.AUTO,\n    none: FunctionCallingMode.NONE,\n  };\n\n  if (toolChoice && [\"any\", \"auto\", \"none\"].includes(toolChoice as string)) {\n    return {\n      functionCallingConfig: {\n        mode: modeMap[toolChoice as keyof typeof modeMap] ?? \"MODE_UNSPECIFIED\",\n        allowedFunctionNames,\n      },\n    };\n  }\n\n  if (typeof toolChoice === \"string\" || allowedFunctionNames) {\n    return {\n      functionCallingConfig: {\n        mode: FunctionCallingMode.ANY,\n        allowedFunctionNames: [\n          ...(allowedFunctionNames ?? []),\n          ...(toolChoice && typeof toolChoice === \"string\" ? [toolChoice] : []),\n        ],\n      },\n    };\n  }\n\n  return undefined;\n}\n"],"mappings":";;;;;;;AAmBA,SAAgB,oBACd,OACA,OAOA;CAEA,MAAM,aAAa,aAAa,MAAM;AAKtC,QAAO;EAAE,OAAO;EAAY,YAFT,iBAAiB,YAAY,MAAM;EAEd;;AAG1C,SAAS,aAAa,OAAyD;CAC7E,IAAI,2BAAkD,EAAE;CACxD,MAAM,aAAiC,EAAE;AAEzC,OAAM,SAAS,SAAS;AACtB,MAAI,gBAAgB,KAAK,EAAE;GACzB,MAAM,CAAC,iBAAiB,2BAA2B,CACjD,KACD,CAAC;AACF,OAAI,cAAc,qBAChB,0BAAyB,KAAK,GAAG,cAAc,qBAAqB;aAE7D,aAAa,KAAK,EAAE;GAC7B,MAAM,EAAE,yBAAyB,yBAAyB,KAAK;AAC/D,OAAI,qBACF,0BAAyB,KAAK,GAAG,qBAAqB;OAEtD,OAAM,IAAI,MACR,gEACD;QAGH,YAAW,KAAK,KAAyB;GAE3C;AAKF,KAHiC,WAAW,MACzC,MAAM,0BAA0B,EAClC,CAEC,QAAO,WAAW,KAAK,SAAS;AAC9B,MACE,0BAA0B,SAAS,KACnC,0BAA0B,MAC1B;GACA,MAAM,UAAU,EACd,sBAAsB,CACpB,GAAI,KAAK,wBAAwB,EAAE,EACnC,GAAG,yBACJ,EACF;AAED,8BAA2B,EAAE;AAC7B,UAAO;;AAET,SAAO;GACP;AAGJ,QAAO,CACL,GAAG,YACH,GAAI,yBAAyB,SAAS,IAClC,CACE,EACE,sBAAsB,0BACvB,CACF,GACD,EAAE,CACP;;AAGH,SAAS,yBACP,MAC0B;AAC1B,QAAO,EACL,sBAAsB,CACpB;EACE,MAAM,KAAK,SAAS;EACpB,aAAa,KAAK,SAAS;EAC3B,YAAY,2BACV,KAAK,SAAS,WACf;EACF,CACF,EACF;;AAGH,SAAS,iBACP,YACA,OAIwB;AACxB,KAAI,CAAC,WAAW,UAAU,CAAC,MAAO,QAAO;CAEzC,MAAM,EAAE,YAAY,yBAAyB;CAE7C,MAAM,UAA+C;EACnD,KAAK,oBAAoB;EACzB,MAAM,oBAAoB;EAC1B,MAAM,oBAAoB;EAC3B;AAED,KAAI,cAAc;EAAC;EAAO;EAAQ;EAAO,CAAC,SAAS,WAAqB,CACtE,QAAO,EACL,uBAAuB;EACrB,MAAM,QAAQ,eAAuC;EACrD;EACD,EACF;AAGH,KAAI,OAAO,eAAe,YAAY,qBACpC,QAAO,EACL,uBAAuB;EACrB,MAAM,oBAAoB;EAC1B,sBAAsB,CACpB,GAAI,wBAAwB,EAAE,EAC9B,GAAI,cAAc,OAAO,eAAe,WAAW,CAAC,WAAW,GAAG,EAAE,CACrE;EACF,EACF"}