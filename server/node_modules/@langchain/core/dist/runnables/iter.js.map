{"version":3,"file":"iter.js","names":[],"sources":["../../src/runnables/iter.ts"],"sourcesContent":["import type { RunnableConfig } from \"../runnables/types.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { pickRunnableConfigKeys } from \"./config.js\";\n\nexport function isIterableIterator(\n  thing: unknown\n): thing is IterableIterator<unknown> {\n  return (\n    typeof thing === \"object\" &&\n    thing !== null &&\n    typeof (thing as Generator)[Symbol.iterator] === \"function\" &&\n    // avoid detecting array/set as iterator\n    typeof (thing as Generator).next === \"function\"\n  );\n}\n\nexport const isIterator = (x: unknown): x is Iterator<unknown> =>\n  x != null &&\n  typeof x === \"object\" &&\n  \"next\" in x &&\n  typeof x.next === \"function\";\n\nexport function isAsyncIterable(\n  thing: unknown\n): thing is AsyncIterable<unknown> {\n  return (\n    typeof thing === \"object\" &&\n    thing !== null &&\n    typeof (thing as AsyncIterable<unknown>)[Symbol.asyncIterator] ===\n      \"function\"\n  );\n}\n\nexport function isAsyncGenerator(x: unknown): x is AsyncGenerator {\n  return (\n    x != null &&\n    typeof x === \"object\" &&\n    typeof (x as AsyncGenerator).next === \"function\"\n  );\n}\n\nexport async function consumeAsyncGenerator<T, TReturn>(\n  generator: AsyncGenerator<T, TReturn>,\n  onYield?: (value: T) => Promise<void> | void\n): Promise<TReturn> {\n  try {\n    let iterResult = await generator.next();\n    while (!iterResult.done) {\n      await onYield?.(iterResult.value);\n      iterResult = await generator.next();\n    }\n    return iterResult.value;\n  } finally {\n    await generator.return?.(undefined as TReturn);\n  }\n}\n\nexport function* consumeIteratorInContext<T>(\n  context: Partial<RunnableConfig> | undefined,\n  iter: IterableIterator<T>\n): IterableIterator<T> {\n  while (true) {\n    const { value, done } = AsyncLocalStorageProviderSingleton.runWithConfig(\n      pickRunnableConfigKeys(context),\n      iter.next.bind(iter),\n      true\n    );\n    if (done) {\n      break;\n    } else {\n      yield value;\n    }\n  }\n}\n\nexport async function* consumeAsyncIterableInContext<T>(\n  context: Partial<RunnableConfig> | undefined,\n  iter: AsyncIterable<T>\n): AsyncIterableIterator<T> {\n  const iterator = iter[Symbol.asyncIterator]();\n  while (true) {\n    const { value, done } =\n      await AsyncLocalStorageProviderSingleton.runWithConfig(\n        pickRunnableConfigKeys(context),\n        iterator.next.bind(iter),\n        true\n      );\n    if (done) {\n      break;\n    } else {\n      yield value;\n    }\n  }\n}\n"],"mappings":";;;;;AAIA,SAAgB,mBACd,OACoC;AACpC,QACE,OAAO,UAAU,YACjB,UAAU,QACV,OAAQ,MAAoB,OAAO,cAAc,cAEjD,OAAQ,MAAoB,SAAS;;AAIzC,MAAa,cAAc,MACzB,KAAK,QACL,OAAO,MAAM,YACb,UAAU,KACV,OAAO,EAAE,SAAS;AAEpB,SAAgB,gBACd,OACiC;AACjC,QACE,OAAO,UAAU,YACjB,UAAU,QACV,OAAQ,MAAiC,OAAO,mBAC9C;;AAIN,SAAgB,iBAAiB,GAAiC;AAChE,QACE,KAAK,QACL,OAAO,MAAM,YACb,OAAQ,EAAqB,SAAS;;AAI1C,eAAsB,sBACpB,WACA,SACkB;AAClB,KAAI;EACF,IAAI,aAAa,MAAM,UAAU,MAAM;AACvC,SAAO,CAAC,WAAW,MAAM;AACvB,SAAM,UAAU,WAAW,MAAM;AACjC,gBAAa,MAAM,UAAU,MAAM;;AAErC,SAAO,WAAW;WACV;AACR,QAAM,UAAU,SAAS,OAAqB;;;AAIlD,UAAiB,yBACf,SACA,MACqB;AACrB,QAAO,MAAM;EACX,MAAM,EAAE,OAAO,SAAS,mCAAmC,cACzD,uBAAuB,QAAQ,EAC/B,KAAK,KAAK,KAAK,KAAK,EACpB,KACD;AACD,MAAI,KACF;MAEA,OAAM;;;AAKZ,gBAAuB,8BACrB,SACA,MAC0B;CAC1B,MAAM,WAAW,KAAK,OAAO,gBAAgB;AAC7C,QAAO,MAAM;EACX,MAAM,EAAE,OAAO,SACb,MAAM,mCAAmC,cACvC,uBAAuB,QAAQ,EAC/B,SAAS,KAAK,KAAK,KAAK,EACxB,KACD;AACH,MAAI,KACF;MAEA,OAAM"}